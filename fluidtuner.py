#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Quick batch generating of Fluidsynth tuning data from any number of 12-note tunings stored 
in a simple, human-readable text file.

    - Tuning information to be processed is stored in its own separate text file:
        - Each line is a single 12-note tuning consisting of a comma-separated list of ratios, e.g.:
            - 1/1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8
        - Note: the program ignores whitespace, so each line may be formatted with whitespace as desired 
          as long as each tone in the tuning is separated by a comma and contains a "/" to separate the 
          numerator and the denominator of the ratio
        - Python-style comments may be included in this file if they are on their own lines and begin with a #

Written by Thomas Nicholson, June 2024
www.superparticular.com

usage: python3 fluidtuner.py [-h] [--unity] [--offset] [--name] [--bank] [--program] [--output] input
Note: unity must be one of C, C#, Db, D, D#, Eb, E, F, F#, Gb, G, G#, Ab, A, A#, Bb, B}

For more information run: python3 fluidtuner.py -h
"""

from math import log2, floor
from time import sleep
from argparse import ArgumentParser

def with_denominator(val: str) :
    if not "/" in val :
        val += "/1"
    return val

print("*********************\nWelcome to Fluidtuner\n*********************")
t = 0.5
sleep(t)

midi_lookup = { "C" : 0, "C#" : 1, "Db" : 1, "D" : 2, "D#" : 3, "Eb" : 3, "E" : 4, "F" : 5, "F#" : 6,
               "Gb" : 6, "G" : 7, "G#" : 8, "Ab" : 8, "A" : 9, "A#" : 10, "Bb" : 10, "B" : 11 }

parser = ArgumentParser(
    prog = "Fluidtuner",
    description = "A program for quick batch generating of Fluidsynth tuning data from any number of 12-note tunings stored in a simple, human-readable text file."
    )
parser.add_argument("input", 
                    help="a text file file in which each line is a 12-note tuning consisting of a comma-separated list of ratios, e.g.: 1/1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8 (note: 2/1 should not included, however it is not necessary for the tuning to begin with 1/1)"
                    )
parser.add_argument("--unity", 
                    choices=["C", "C#", "Db", "D", "D#", "Eb", "E", "F", "F#", "Gb", "G", "G#", "Ab", "A", "A#", "Bb", "B"],
                    default="C",
                    help="the chromatic note of the tuning's unity 1/1 (default: C) - Note: the diatonic note name must be capitalized"
                    )
parser.add_argument("--offset",
                    default="1/1",
                    help="an offset ratio for the tuning's unity with respect to another reference pitch or Kammerton, where the reference pitch = cents and unity = some cent deviation (default: 1/1, i.e. unity = 0 cents)"
                    )
parser.add_argument("--name", 
                    default="MyTuning",
                    help="the name of your tuning (default: MyTuning)"
                    )
parser.add_argument("--bank", 
                    type=int, 
                    default=1,
                    help="Fluidsynth tuning bank (default: 1)"
                    )
parser.add_argument("--program", 
                    type=int, 
                    default=0,
                    help="program number in bank as start point (default: 0)"
                    )
parser.add_argument("--output", 
                    default="fluidtuner_output.txt",
                    help="filename for output data (default: fluidtuner_output.txt)"
                    )
args = parser.parse_args()
offset_num, offset_den = with_denominator(args.offset).split("/")
args.offset = float(offset_num)/float(offset_den)
args.name = args.name.replace(" ", "")

print(f"\nReading in your file {args.input} and parsing your arguments...")
sleep(t)

# Read the input file and create the tuning list
tuning_list = []
with open(args.input) as file:
    for line in file :
        if line != "\n" and line.startswith("#") == False:
            line = line.replace(" ", "")
            if line.endswith(",\n") :
                line = line[:-2]
            line = line.split(",")
            tuning = []
            for tone in line :
                num, den = with_denominator(tone).split("/") 
                tone = float(num)/float(den)
                tuning.append(tone)
            tuning_list.append(tuning)
    
print(f"Fluidtuner will process ** {len(tuning_list)} ** tunings")
print("\nVerifying that each tuning has 12 tones...")
sleep(t)

# Throw exception if a tuning does not have 12 notes
for index, tuning in enumerate(tuning_list) :
    if len(tuning) != 12 :
        raise Exception(f"Tuning {index + 1} in your tuning list does not contain 12 tones!")

print("Generating Fluidsynth data...")
sleep(t)

# Create Fluidsynth output
output = "# Tuning data generated by Fluidtuner.py\n"
for tuning_index, tuning in enumerate(tuning_list) :
    tuning_number = tuning_index + 1
    output += f"\n# Tuning {tuning_number}\n"
    tuning_index += args.program
    overflow = floor(tuning_index/128)
    tuning_index -= (overflow * 128)
    output += f"tuning {args.name}_{tuning_number} {args.bank + overflow} {tuning_index}\n"
    cent_vals = []
    for tone in tuning :
        cents = 1200 * log2(tone * args.offset) - (round((1200 * log2(args.offset))/100) * 100)
        cent_vals.append(cents)
    key_vals = ""
    for i in range(0, 128) :
        pos = (i - midi_lookup[args.unity])
        octave = floor(i/12) * 1200
        if pos < 0 :
            octave += -1200
        key_vals += f"tune {args.bank + overflow} {tuning_index} {i} {round(cent_vals[pos % 12] + octave + (midi_lookup[args.unity] * 100), 4)}\n"
    output += key_vals

with open(args.output, "w") as o:
    print(output, file=o)

print(f"Your Fluidynth data was saved to {args.output}\n")
sleep(t)
print("********\nGoodbye!\n********")